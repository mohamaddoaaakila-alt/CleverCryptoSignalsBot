import sqlite3
import hashlib
import random
import json
import time
import logging
import os
import re
import numpy as np
import pandas as pd
import requests
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Updater, CommandHandler, CallbackContext, CallbackQueryHandler, MessageHandler, Filters,
    JobQueue
)
from cryptography.fernet import Fernet
from PIL import Image, ImageDraw, ImageFont
from bs4 import BeautifulSoup
import snscrape.modules.twitter as sntwitter
from sklearn.ensemble import IsolationForest
from fake_useragent import UserAgent

# ===== ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ =====
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ===== ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ =====
conn = sqlite3.connect('golden_pyramid.db', check_same_thread=False)
c = conn.cursor()

# ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ¨ÿØÿßŸàŸÑ
c.execute('''CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    username TEXT,
    join_date TEXT DEFAULT CURRENT_TIMESTAMP,
    last_login TEXT,
    points INTEGER DEFAULT 0,
    level INTEGER DEFAULT 1,
    referral_code TEXT,
    referrer_id INTEGER,
    verified BOOLEAN DEFAULT FALSE,
    total_earned INTEGER DEFAULT 0,
    total_spent INTEGER DEFAULT 0,
    wallet_address TEXT,
    free_recommendations_used INTEGER DEFAULT 0,
    trust_score INTEGER DEFAULT 100,
    escrow_balance REAL DEFAULT 0,
    debt REAL DEFAULT 0
)''')

c.execute('''CREATE TABLE IF NOT EXISTS referrals (
    referral_id INTEGER PRIMARY KEY AUTOINCREMENT,
    referrer_id INTEGER,
    referred_id INTEGER,
    level INTEGER,
    date TEXT DEFAULT CURRENT_TIMESTAMP,
    verified BOOLEAN DEFAULT FALSE
)''')

c.execute('''CREATE TABLE IF NOT EXISTS transactions (
    tx_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    points INTEGER,
    type TEXT,
    date TEXT DEFAULT CURRENT_TIMESTAMP,
    description TEXT
)''')

c.execute('''CREATE TABLE IF NOT EXISTS quests (
    quest_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    quest_type TEXT,
    progress INTEGER DEFAULT 0,
    completed BOOLEAN DEFAULT FALSE,
    date TEXT DEFAULT CURRENT_TIMESTAMP
)''')

c.execute('''CREATE TABLE IF NOT EXISTS recommendations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    symbol TEXT,
    name TEXT,
    recommendation TEXT,
    reason TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    profit REAL DEFAULT 0,
    verified BOOLEAN DEFAULT FALSE
)''')

c.execute('''CREATE TABLE IF NOT EXISTS audits (
    audit_id INTEGER PRIMARY KEY AUTOINCREMENT,
    trade_id INTEGER,
    auditor_id INTEGER,
    vote TEXT,
    comments TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)''')

c.execute('''CREATE TABLE IF NOT EXISTS user_achievements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    achievement_id TEXT,
    progress INTEGER DEFAULT 0
)''')

c.execute('''CREATE TABLE IF NOT EXISTS achievements_unlocked (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    achievement_id TEXT,
    date TEXT DEFAULT CURRENT_TIMESTAMP
)''')

c.execute('''CREATE TABLE IF NOT EXISTS user_interests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    symbol TEXT
)''')

conn.commit()

# ===== ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ∞ŸÉŸäÿ© =====
class SmartConfig:
    def __init__(self):
        self.POINT_VALUE = 0.001
        self.CONVERSION_FEE = 0.6
        self.MIN_CONVERSION = 5000
        self.MAX_POINTS_PER_USER = 10000
        self.REFERRAL_REWARDS = {1: 500, 2: 250, 3: 100}
        self.REFERRAL_VERIFICATION_DAYS = 3
        self.REFERRAL_BONUS_THRESHOLDS = {5: 200, 10: 500, 20: 1000}
        self.BASE_RECOMMENDATION_PRICE = 10
        self.PRICE_DYNAMICS = {
            'new_user_discount': 0.5,
            'active_user_discount': 0.2,
            'high_balance_penalty': 0.3
        }
        self.COMMISSION_RATE = 0.15
        self.MIN_TRADE_SIZE = 10
        self.MAX_DEVIATION = 0.05
        self.TRUST_SCORE_RANGES = {
            'high': (80, 100),
            'medium': (50, 79),
            'low': (0, 49)
        }
        self.POINT_BURN_RATE = 0.05
        self.ECONOMIC_CHECK_INTERVAL = 604800
        self.DAILY_REWARD = 10
        self.QUESTS = {
            'daily': [
                {"id": "login", "points": 10, "desc": "ÿ≥ÿ¨ŸÑ ÿØÿÆŸàŸÑ ŸäŸàŸÖŸä"},
                {"id": "share", "points": 30, "desc": "ÿ¥ÿßÿ±ŸÉ ÿßŸÑÿ®Ÿàÿ™"},
                {"id": "audit", "points": 50, "desc": "ÿ™ÿØŸÇŸäŸÇ ÿµŸÅŸÇÿ©"}
            ],
            'weekly': [
                {"id": "refer_3", "points": 200, "desc": "ÿ£ÿ≠ŸêŸÑ 3 ÿ£ÿµÿØŸÇÿßÿ°"},
                {"id": "trade_5", "points": 150, "desc": "ŸÜŸÅÿ∞ 5 ÿµŸÅŸÇÿßÿ™"}
            ]
        }
        self.SUPPORTED_CURRENCIES = ['USD', 'BTC', 'ETH']
        self.MARKET_THRESHOLDS = {
            'bearish': {'fee': 0.5, 'price': 8},
            'bullish': {'fee': 0.7, 'price': 12},
            'normal': {'fee': 0.6, 'price': 10}
        }
        self.FREE_RECOMMENDATIONS = 1
        self.TRIAL_PERIOD = 30
        self.ANALYSTS = [
            "Crypto_Arabia", "Binance_KSA", "CryptoSheikh", "ArabWhale", "EmiratesCrypto",
            "Qatar_Bitcoin", "EgyptBlockchain", "IraqiCrypto", "KuwaitCoin", "Oman_Bitcoin",
            "YemeniTrader", "SyrianCrypto", "JordanCrypto", "LebanonCrypto", "TunisiaBlockchain",
            "AlgeriaCrypto", "MoroccoCrypto", "Sudan_Bitcoin", "LibyaCrypto", "MauritaniaCrypto"
        ]
        self.TOP_100_COINS = [
            "BTC", "ETH", "BNB", "SOL", "XRP", "ADA", "AVAX", "DOT", "DOGE", "SHIB",
            "MATIC", "LTC", "TRX", "LINK", "ATOM", "UNI", "XLM", "ALGO", "VET", "ICP"
        ]
        self.CACHE_DIR = "cache"
        os.makedirs(self.CACHE_DIR, exist_ok=True)
        self.ADMIN_CHANNEL = "@GoldenPyramidAdmin"
        self.ADMIN_ID = "YOUR_ADMIN_ID"

config = SmartConfig()

# ===== ŸÜÿ∏ÿßŸÖ ÿ¨ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∞ŸÉŸäÿ© =====
class DataCollector:
    def __init__(self, config):
        self.config = config
        self.ua = UserAgent()
        
    def get_cache_or_fetch(self, key, fetch_function, expiration=3600):
        cache_file = os.path.join(self.config.CACHE_DIR, f"{key}.json")
        
        if os.path.exists(cache_file):
            modified_time = os.path.getmtime(cache_file)
            if (time.time() - modified_time) < expiration:
                try:
                    with open(cache_file, "r") as f:
                        return json.load(f)
                except:
                    pass
        
        data = fetch_function()
        
        if data:
            try:
                with open(cache_file, "w") as f:
                    json.dump(data, f)
            except:
                pass
            return data
            
        return None
        
    def fetch_top_coins(self):
        try:
            url = "https://api.coingecko.com/api/v3/coins/markets"
            params = {
                "vs_currency": "usd",
                "order": "market_cap_desc",
                "per_page": 20,
                "page": 1,
                "sparkline": False
            }
            headers = {'User-Agent': self.ua.random}
            response = requests.get(url, headers=headers, params=params, timeout=15)
            response.raise_for_status()
            
            coins = []
            for coin in response.json():
                coins.append({
                    'symbol': coin['symbol'].upper(),
                    'name': coin['name'],
                    'price': coin['current_price']
                })
            
            return coins
        
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÖŸÑÿßÿ™: {str(e)}")
            return [
                {"symbol": coin, "name": coin, "price": 0.0} 
                for coin in self.config.TOP_100_COINS[:20]
            ]

    def fetch_analyst_recommendations(self):
        recommendations = []
        today = datetime.now().date()
        
        for analyst in self.config.ANALYSTS:
            try:
                query = f'from:{analyst} (ÿ¥ÿ±ÿßÿ° OR ÿ®Ÿäÿπ OR ÿßÿ≠ÿ™ŸÅÿßÿ∏) since:{today}'
                for tweet in sntwitter.TwitterSearchScraper(query).get_items():
                    content = tweet.content
                    coins = re.findall(r'\b([A-Z]{3,5})\b', content)
                    
                    recommendations.append({
                        'analyst': analyst,
                        'content': content,
                        'coins': list(set(coins)),
                        'timestamp': tweet.date.isoformat()
                    })
            except Exception as e:
                logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ {analyst}: {str(e)}")
        
        return recommendations

# ===== ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉŸä =====
class AnalysisEngine:
    def __init__(self, config):
        self.config = config
        self.model = IsolationForest(n_estimators=100, contamination=0.1, random_state=42)
        
    def analyze_data(self, coins_data, recommendations_data):
        try:
            coins = coins_data
            recs = recommendations_data
            
            analysis_data = []
            for coin in coins:
                symbol = coin['symbol']
                coin_recs = [r for r in recs if symbol in r['coins']]
                
                if coin_recs:
                    sentiment = self.calculate_sentiment(coin_recs)
                    analysis_data.append({
                        'symbol': symbol,
                        'sentiment': sentiment,
                        'mentions': len(coin_recs)
                    })
            
            if analysis_data:
                X = np.array([[d['sentiment'], d['mentions']] for d in analysis_data])
                self.model.fit(X)
                predictions = self.model.predict(X)
                
                recommendations = []
                for i, data in enumerate(analysis_data):
                    if predictions[i] == -1:
                        recommendations.append({
                            'symbol': data['symbol'],
                            'name': next((c['name'] for c in coins if c['symbol'] == data['symbol']), data['symbol']),
                            'sentiment': data['sentiment'],
                            'mentions': data['mentions'],
                            'recommendation': "üöÄ ÿ¥ÿ±ÿßÿ° ŸÇŸàŸä" if data['sentiment'] > 0 else "üîª ÿ®Ÿäÿπ ŸÅŸàÿ±Ÿä",
                            'reason': "ÿ™ÿ≠ŸÑŸäŸÑ ÿ•Ÿäÿ¨ÿßÿ®Ÿä ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÑŸÑŸäŸÜ" if data['sentiment'] > 0 else "ÿ™ÿ≠ŸÑŸäŸÑ ÿ≥ŸÑÿ®Ÿä ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÑŸÑŸäŸÜ"
                        })
                
                return sorted(recommendations, key=lambda x: abs(x['sentiment']), reverse=True)[:5]
        
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ: {str(e)}")
        
        return [{
            'symbol': "BTC",
            'name': "Bitcoin",
            'recommendation': "üöÄ ÿ¥ÿ±ÿßÿ° ŸÇŸàŸä",
            'reason': "ÿ£ÿØÿßÿ° ÿ™ÿßÿ±ŸäÿÆŸä ŸÇŸàŸä Ÿàÿ™ÿ≠ŸÑŸäŸÑ ÿ•Ÿäÿ¨ÿßÿ®Ÿä ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÑŸÑŸäŸÜ",
            'sentiment': 0.85,
            'mentions': 15
        }]
        
    def calculate_sentiment(self, recommendations):
        positive_keywords = ["ÿ¥ÿ±ÿßÿ°", "ŸÖŸÖÿ™ÿßÿ≤", "ÿ¨ŸäÿØ", "Ÿäÿ±ÿ™ŸÅÿπ", "ŸÇŸàŸä", "ŸÅÿ±ÿµÿ©", "ŸÖÿ≥ÿ™ŸÇÿ®ŸÑ", "ÿ≤ŸäÿßÿØÿ©"]
        negative_keywords = ["ÿ®Ÿäÿπ", "ÿ∂ÿπŸäŸÅ", "Ÿáÿ®Ÿàÿ∑", "ÿ™ÿ¨ŸÜÿ®", "ÿÆÿ∑ÿ±", "ÿßŸÜÿÆŸÅÿßÿ∂", "ŸÖÿ¥ŸÉŸÑÿ©"]
        
        total_score = 0
        for rec in recommendations:
            score = 0
            content = rec['content'].lower()
            
            for word in positive_keywords:
                if word in content:
                    score += 1
                    
            for word in negative_keywords:
                if word in content:
                    score -= 1
                    
            total_score += max(-1, min(1, score / 3))
            
        return total_score / len(recommendations) if recommendations else 0

# ===== ŸÜÿ∏ÿßŸÖ ŸÖŸÉÿßŸÅÿ≠ÿ© ÿßŸÑÿ™ÿ∂ÿÆŸÖ =====
class PointEconomy:
    @staticmethod
    def adjust_supply():
        try:
            c.execute("SELECT SUM(points) FROM users")
            total_points = c.fetchone()[0] or 0
            
            burn_amount = int(total_points * config.POINT_BURN_RATE)
            c.execute("UPDATE users SET points = points * ?", 
                     (1 - config.POINT_BURN_RATE,))
            conn.commit()
            
            logger.info(f"ÿ™ŸÖ ÿ≠ÿ±ŸÇ {burn_amount} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿßŸÑÿπÿ±ÿ∂")
            return burn_amount
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ∂ÿ®ÿ∑ ÿßŸÑÿπÿ±ÿ∂: {e}")
            return 0

    @staticmethod
    def get_economic_status():
        try:
            c.execute("SELECT SUM(points) FROM users")
            total_circulating = c.fetchone()[0] or 0
            
            c.execute("SELECT SUM(total_earned) FROM users")
            total_earned = c.fetchone()[0] or 0
            
            c.execute("SELECT SUM(total_spent) FROM users")
            total_spent = c.fetchone()[0] or 0
            
            return {
                'circulating': total_circulating,
                'total_earned': total_earned,
                'total_spent': total_spent,
                'health_ratio': total_spent / (total_earned + 1)
            }
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿßŸÇÿ™ÿµÿßÿØŸäÿ©: {e}")
            return {}

# ===== ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ =====
class VerificationSystem:
    @staticmethod
    def verify_user(user_id):
        try:
            c.execute("SELECT COUNT(*) FROM transactions WHERE user_id = ?", (user_id,))
            activity_count = c.fetchone()[0]
            
            if activity_count >= 3:
                c.execute("UPDATE users SET verified = TRUE WHERE user_id = ?", (user_id,))
                conn.commit()
                return True
            return False
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}")
            return False

    @staticmethod
    def verify_referrals():
        try:
            c.execute('''SELECT referral_id, referrer_id 
                         FROM referrals 
                         WHERE verified = FALSE 
                         AND date < DATE('now', ?)''',
                     (f'-{config.REFERRAL_VERIFICATION_DAYS} days',))
            
            unverified = c.fetchall()
            for ref_id, referrer_id in unverified:
                if VerificationSystem.verify_user(referrer_id):
                    c.execute("UPDATE referrals SET verified = TRUE WHERE referral_id = ?", (ref_id,))
                    c.execute("SELECT level FROM referrals WHERE referral_id = ?", (ref_id,))
                    level = c.fetchone()[0]
                    reward = config.REFERRAL_REWARDS.get(level, 0)
                    PointSystem.add_points(referrer_id, reward, f"ŸÖŸÉÿßŸÅÿ£ÿ© ÿ•ÿ≠ÿßŸÑÿ© ŸÖÿ§ŸÉÿØÿ© - ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ {level}")
            
            conn.commit()
            return len(unverified)
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ≠ÿßŸÑÿßÿ™: {e}")
            return 0

# ===== ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÜŸÇÿßÿ∑ =====
class PointSystem:
    @staticmethod
    def add_points(user_id, amount, reason=""):
        try:
            c.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
            current = c.fetchone()[0] or 0
            
            new_total = min(current + amount, config.MAX_POINTS_PER_USER)
            c.execute("UPDATE users SET points = ?, total_earned = total_earned + ? WHERE user_id = ?", 
                     (new_total, amount, user_id))
            
            c.execute('''INSERT INTO transactions 
                         (user_id, points, type, description)
                         VALUES (?, ?, 'earn', ?)''',
                     (user_id, amount, reason))
            conn.commit()
            
            return new_total
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÜŸÇÿßÿ∑: {e}")
            return 0

    @staticmethod
    def spend_points(user_id, amount, reason=""):
        try:
            c.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
            current_points = c.fetchone()[0] or 0
            
            if current_points >= amount:
                c.execute("UPDATE users SET points = points - ?, total_spent = total_spent + ? WHERE user_id = ?", 
                         (amount, amount, user_id))
                
                c.execute('''INSERT INTO transactions 
                             (user_id, points, type, description)
                             VALUES (?, ?, 'spend', ?)''',
                         (user_id, amount, reason))
                conn.commit()
                return True
            return False
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿÆÿµŸÖ ÿßŸÑŸÜŸÇÿßÿ∑: {e}")
            return False

# ===== ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ŸàÿµŸäÿßÿ™ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑ =====
class RecommendationEngine:
    def __init__(self, config):
        self.config = config
        self.collector = DataCollector(config)
        self.analyzer = AnalysisEngine(config)
        self.recommendations = []
        self.last_update = datetime.min

    def get_dynamic_price(self, user_id):
        try:
            base_price = self.config.BASE_RECOMMENDATION_PRICE
            
            c.execute("SELECT join_date FROM users WHERE user_id = ?", (user_id,))
            join_date = datetime.strptime(c.fetchone()[0], '%Y-%m-%d')
            if (datetime.now() - join_date).days < 3:
                return int(base_price * (1 - self.config.PRICE_DYNAMICS['new_user_discount']))
            
            c.execute('''SELECT COUNT(*) FROM transactions 
                         WHERE user_id = ? AND date > DATE('now', '-7 days')''',
                     (user_id,))
            weekly_activity = c.fetchone()[0]
            if weekly_activity > 5:
                return int(base_price * (1 - self.config.PRICE_DYNAMICS['active_user_discount']))
            
            c.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
            user_points = c.fetchone()[0] or 0
            if user_points > 5000:
                return int(base_price * (1 + self.config.PRICE_DYNAMICS['high_balance_penalty']))
            
            return base_price
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ≥ÿπÿ±: {e}")
            return self.config.BASE_RECOMMENDATION_PRICE

    def generate_recommendation(self, user_id, use_free=False):
        try:
            if use_free:
                today = datetime.now().strftime("%Y-%m-%d")
                c.execute("SELECT free_recommendations_used FROM users WHERE user_id = ?", (user_id,))
                free_used = c.fetchone()[0] or 0
                
                if free_used >= self.config.FREE_RECOMMENDATIONS:
                    return None
                
                price = 0
            else:
                price = self.get_dynamic_price(user_id)
            
            if not self.recommendations or (datetime.now() - self.last_update).seconds > 3600:
                coins_data = self.collector.get_cache_or_fetch(
                    "top_coins", 
                    self.collector.fetch_top_coins,
                    expiration=3600
                )
                recs_data = self.collector.get_cache_or_fetch(
                    "analyst_recommendations",
                    self.collector.fetch_analyst_recommendations,
                    expiration=1800
                )
                if coins_data and recs_data:
                    self.recommendations = self.analyzer.analyze_data(coins_data, recs_data)
                    self.last_update = datetime.now()
            
            if not self.recommendations:
                coins = ["BTC", "ETH", "XRP", "ADA", "SOL", "DOT", "AVAX", "MATIC"]
                actions = ["ÿ¥ÿ±ÿßÿ°", "ÿ®Ÿäÿπ", "ÿßÿ≠ÿ™ŸÅÿßÿ∏"]
                strengths = ["ŸÇŸàŸäÿ©", "ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©", "ÿ∂ÿπŸäŸÅÿ©"]
                
                recommendation = {
                    "symbol": random.choice(coins),
                    "name": random.choi